{"remainingRequest":"/Users/anubz/Documents/Ativadores/offline1 - cópia/node_modules/babel-loader/lib/index.js!/Users/anubz/Documents/Ativadores/offline1 - cópia/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/anubz/Documents/Ativadores/offline1 - cópia/src/components/QrcodeReader.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/anubz/Documents/Ativadores/offline1 - cópia/src/components/QrcodeReader.vue","mtime":1523477480832},{"path":"/Users/anubz/Documents/Ativadores/offline1 - cópia/.babelrc","mtime":1526042178021},{"path":"/Users/anubz/Documents/Ativadores/offline1 - cópia/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/Users/anubz/Documents/Ativadores/offline1 - cópia/node_modules/babel-loader/lib/index.js","mtime":1519636541000},{"path":"/Users/anubz/Documents/Ativadores/offline1 - cópia/node_modules/vue-loader/lib/index.js","mtime":1525995699000}],"contextDependencies":[],"result":["import _toConsumableArray from \"/Users/anubz/Documents/Ativadores/offline1 - co\\u0301pia/node_modules/@babel/runtime/helpers/builtin/es6/toConsumableArray\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/Users/anubz/Documents/Ativadores/offline1 - co\\u0301pia/node_modules/@babel/runtime/helpers/builtin/es6/asyncToGenerator\";\nimport _objectSpread from \"/Users/anubz/Documents/Ativadores/offline1 - co\\u0301pia/node_modules/@babel/runtime/helpers/builtin/es6/objectSpread\";\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nvar $ = require('jquery');\n\nimport jsQR from 'jsqr';\nimport isBoolean from 'lodash/isBoolean';\nvar NO_LOCATION = []; // use specific array instance to guarantee equality ([] !== [] but NO_LOCATION === NO_LOCATION)\n\nvar LOCATE_INTERVAL = 40; // milliseconds\n\nvar DECODE_INTERVAL = 400; // milliseconds\n\nexport default {\n  name: \"qrcode-reader\",\n  props: {\n    paused: {\n      type: Boolean,\n      default: false\n    },\n    videoConstraints: {\n      type: [Object, Boolean],\n      default: function _default() {\n        return {};\n      } // empty object\n\n    }\n  },\n  data: function data() {\n    return {\n      // current video stream instance returned by `getUserMedia`\n      stream: null,\n      // absolute resolution of the current video stream\n      streamWidth: null,\n      streamHeight: null,\n      // whether or not first frame of current video stream has loaded yet\n      streamLoaded: true,\n      // most recent decoded QR code content.\n      // Is only null after unpause or before init, otherwise string.\n      decodeResult: null,\n      // array of most recent detected QR code corner coordinates\n      locateResult: NO_LOCATION,\n      // canvas 2D rendering context to capture stream frames with\n      canvasContext: null\n    };\n  },\n  computed: {\n    /**\n     * Conditions applying for both locating and decoding, joined in a single\n     * computed property.\n     */\n    shouldScan: function shouldScan() {\n      return !this.paused && this.streamLoaded;\n    },\n\n    /**\n     * QR codes should only be actively decoded if the parent component has an\n     * event listener registered. Otherwise the rather expensive decoding\n     * operation is continuously executed for nothing.\n     */\n    shouldDecode: function shouldDecode() {\n      return this.shouldScan && this.$listeners.decode !== undefined;\n    },\n\n    /**\n     * Just like with `this.shouldDecode`, locating is not allowed when the\n     * parent component has no event listener registered.\n     */\n    shouldLocate: function shouldLocate() {\n      return this.shouldScan && this.$listeners.locate !== undefined;\n    },\n\n    /**\n     * Full constraints object which is passed to `getUserMedia` to request a\n     * camera stream. Properties define if a certain camera is adequate or not.\n     */\n    constraints: function constraints() {\n      var withDefaults;\n\n      if (isBoolean(this.videoConstraints)) {\n        withDefaults = this.videoConstraints;\n      } else {\n        withDefaults = _objectSpread({\n          facingMode: {\n            ideal: 'environment'\n          },\n          width: {\n            min: 360,\n            ideal: 360,\n            max: 720\n          },\n          height: {\n            min: 240,\n            ideal: 240,\n            max: 480\n          }\n        }, this.videoConstraints);\n      }\n\n      return {\n        audio: false,\n        video: withDefaults\n      };\n    },\n\n    /**\n     * Joins stream resolution information in a single array. Some canvas API\n     * methods expect parameters in this form and order. This is a nice little\n     * helper to pass those values with the spread operator.\n     */\n    streamBounds: function streamBounds() {\n      return [0, 0, this.streamWidth, this.streamHeight];\n    }\n  },\n  watch: {\n    /**\n     * Propagate new decoding results to parent component. Since holding a\n     * camera for a few seconds over a QR code, produces the same result\n     * multiple times in a row, an event is only emitted when the result\n     * value actually changes. To allow re-scanning after the component is\n     * un-paused, decodeResult is set to null (see #8). Null values are never\n     * emitted though.\n     */\n    decodeResult: function decodeResult(newValue) {\n      if (newValue !== null) {\n        this.$emit('decode', newValue);\n      }\n    },\n\n    /**\n     * Propagates location of QR code when it changes. Just like with decoding\n     * results, this event is only emitted when the detected location changes.\n     *\n     * While a QR code is actually in sight, position changes are detected\n     * nearly each scanned frame anyway. While no QR code is detected though,\n     * this makes sure that empty results are only emitted once.\n     */\n    locateResult: function locateResult(newValue) {\n      this.$emit('locate', newValue);\n    },\n\n    /**\n     * Automatically freezes the video stream when conditions for the scanning\n     * process are not fullfilled anymore.\n     */\n    shouldScan: function shouldScan(_shouldScan) {\n      if (_shouldScan) {\n        this.$refs.video.play();\n      } else {\n        this.$refs.video.pause();\n      }\n    },\n\n    /**\n     * Starts continuous decoding process as soon as conditions for that are\n     * fullfilled. The process stops itself automatically when the conditions\n     * are not fullfilled anymore.\n     */\n    shouldDecode: function shouldDecode(_shouldDecode) {\n      if (_shouldDecode) {\n        this.keepDecoding();\n      }\n    },\n\n    /**\n     * Starts continuous locating process as soon as conditions for that are\n     * fullfilled. The process stops itself automatically when the conditions\n     * are not fullfilled anymore.\n     */\n    shouldLocate: function shouldLocate(_shouldLocate) {\n      if (_shouldLocate) {\n        this.keepLocating();\n      }\n    },\n\n    /**\n     * Resets decodeResult when component is un-paused. This way one QR code\n     * can be decoded twice in a row (see #8). Waits though until video is\n     * actually not frozen anymore. Otherwise the last frame from before\n     * pausing would be rescanned.\n     */\n    paused: function paused(newValue) {\n      var _this = this;\n\n      if (newValue === false) {\n        var resetDecodeResult = function resetDecodeResult() {\n          _this.decodeResult = null;\n        };\n\n        var video = this.$refs.video;\n        video.addEventListener('timeupdate', resetDecodeResult, {\n          once: true\n        });\n      }\n    },\n\n    /**\n     * When constraints for the used camera change, a new stream has to be\n     * requested. This bootstraps the hole init process again.\n     */\n    constraints: {\n      deep: true,\n      handler: function handler() {\n        this.$emit('init', this.startCamera());\n      }\n    }\n  },\n\n  /**\n   * Instanly requests a stream from the users camera as soon as the component\n   * is mounted. This can't be done in earlier livecycle hooks because it\n   * requires the video and canvas element to be rendered already.\n   */\n  mounted: function mounted() {\n    this.$emit('init', this.startCamera());\n  },\n\n  /**\n   * If the camera is not released before the component is destroyed, browsers\n   * will indicate that it's still in use and it might be blocked for other\n   * applications.\n   */\n  beforeDestroy: function beforeDestroy() {\n    this.stopCamera();\n  },\n  methods: {\n    /**\n     * Requests a camera stream using the Stream API and based on\n     * `this.constraints`. Then connects the stream to the video element and\n     * waits for it to load. The promise returned here is the payload for the\n     * `init` event. Any error here leads to this promises rejection.\n     */\n    startCamera: function () {\n      var _startCamera = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        var video, streamLoadedPromise, canvas;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('WebRTC API not supported in this browser');\n\n              case 2:\n                this.stopCamera();\n                _context.next = 5;\n                return navigator.mediaDevices.getUserMedia(this.constraints);\n\n              case 5:\n                this.stream = _context.sent;\n                video = this.$refs.video;\n                streamLoadedPromise = new Promise(function (resolve, reject) {\n                  video.addEventListener('loadeddata', resolve, {\n                    once: true\n                  });\n                  video.addEventListener('error', reject, {\n                    once: true\n                  });\n                });\n\n                if (video.srcObject !== undefined) {\n                  video.srcObject = this.stream;\n                } else if (video.mozSrcObject !== undefined) {\n                  video.mozSrcObject = this.stream;\n                } else if (window.URL.createObjectURL) {\n                  video.src = window.URL.createObjectURL(this.stream);\n                } else if (window.webkitURL) {\n                  video.src = window.webkitURL.createObjectURL(this.stream);\n                } else {\n                  video.src = this.stream;\n                }\n\n                video.playsInline = true;\n                video.play(); // firefox does not emit `loadeddata` if video not playing\n\n                _context.next = 13;\n                return streamLoadedPromise;\n\n              case 13:\n                this.streamLoaded = true;\n                this.streamWidth = video.videoWidth;\n                this.streamHeight = video.videoHeight;\n                canvas = document.createElement('canvas');\n                canvas.width = this.streamWidth;\n                canvas.height = this.streamHeight;\n                this.canvasContext = canvas.getContext('2d');\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function startCamera() {\n        return _startCamera.apply(this, arguments);\n      };\n    }(),\n\n    /**\n     * Releases the current camera stream and resets related instance properties.\n     */\n    stopCamera: function stopCamera() {\n      this.streamLoaded = false;\n\n      if (this.stream !== null) {\n        this.stream.getTracks().forEach(function (track) {\n          return track.stop();\n        });\n        this.stream = null;\n        this.streamWidth = null;\n        this.streamHeight = null;\n      }\n    },\n\n    /**\n     * Captures a frame from video stream and draws it to canvas. Then reads\n     * image data from canvas and returns it for further analysis. This extra\n     * step is necessary because it's not possible to read image data from a\n     * video element directly.\n     */\n    captureFrame: function captureFrame() {\n      var _this$canvasContext, _this$canvasContext2;\n\n      (_this$canvasContext = this.canvasContext).drawImage.apply(_this$canvasContext, [this.$refs.video].concat(_toConsumableArray(this.streamBounds)));\n\n      return (_this$canvasContext2 = this.canvasContext).getImageData.apply(_this$canvasContext2, _toConsumableArray(this.streamBounds));\n    },\n\n    /**\n     * Continuously extracts frames from camera stream and tries to decode\n     * potentially pictured QR codes.\n     */\n    keepDecoding: function keepDecoding() {\n      var _this2 = this;\n\n      if (this.shouldDecode) {\n        var imageData = this.captureFrame();\n        window.requestAnimationFrame(function () {\n          var data = imageData.data,\n              width = imageData.width,\n              height = imageData.height;\n          var result = jsQR(data, width, height);\n\n          if (result !== null) {\n            _this2.decodeResult = result.data;\n          }\n\n          window.setTimeout(_this2.keepDecoding, DECODE_INTERVAL);\n        });\n      }\n    },\n\n    /**\n     * Continuously extracts frames from camera stream and tries to locate\n     * potentially pictured QR codes.\n     *\n     * The coordinates are based on the original camera resolution but the\n     * video element is responsive and scales with space available. Therefore\n     * the coordinates are re-calculated to be relative to the video element.\n     */\n    keepLocating: function keepLocating() {\n      var _this3 = this;\n\n      if (this.shouldLocate) {\n        var imageData = this.captureFrame();\n        window.requestAnimationFrame(function () {\n          var data = imageData.data,\n              width = imageData.width,\n              height = imageData.height;\n          var result = jsQR(data, width, height);\n\n          if (result === null) {\n            _this3.locateResult = NO_LOCATION;\n          } else {\n            var video = _this3.$refs.video;\n            var widthRatio = video.offsetWidth / _this3.streamWidth;\n            var heightRatio = video.offsetHeight / _this3.streamHeight;\n            var locationArray = [result.location.topLeftCorner, result.location.topRightCorner, result.location.bottomRightCorner, result.location.bottomLeftCorner];\n            _this3.locateResult = locationArray.map(function (_ref) {\n              var x = _ref.x,\n                  y = _ref.y;\n              return {\n                x: x * widthRatio,\n                y: y * heightRatio\n              };\n            });\n          }\n\n          window.setTimeout(_this3.keepLocating, LOCATE_INTERVAL);\n        });\n      }\n    }\n  }\n};",{"version":3,"sources":["QrcodeReader.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAiBA;;;AACA;AACA;AACA;;AACA;;AACA;;AACA;QAEA;;;YAGA;eACA,AACA;AAHA;;qBAKA;;;QACA,AACA,AACA;;AAJA;AALA;wBAUA;;AAEA;cACA;AACA;mBACA;oBACA;AACA;oBACA;AACA;AACA;oBACA;AACA;oBACA;AACA;qBACA,AACA;AAfA;AAgBA;;AAEA,AACA,AACA,AACA;;;;sCACA;kCACA;AACA;;AACA,AACA,AACA,AACA,AACA;;;;;0CACA;2DACA;AACA;;AACA,AACA,AACA,AACA;;;;0CACA;2DACA;AACA;;AACA,AACA,AACA,AACA;;;;wCACA;UACA;;4CACA;4BACA;aACA;AACA;;mBACA;;;;;iBACA;;;;;iBACA;;gBACA,AACA;AACA;;;eAEA;eACA,AACA;AAHA;AAIA;;AACA,AACA,AACA,AACA,AACA;;;;;0CACA;2CACA;AACA,AACA;AApDA;;AAsDA,AACA,AACA,AACA,AACA,AACA,AACA,AACA;;;;;;;;kDACA;6BACA;6BACA;AACA;AACA;;AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA;;;;;;;;kDACA;2BACA;AACA;;AACA,AACA,AACA,AACA;;;;iDACA;uBACA;yBACA;aACA;yBACA;AACA;AACA;;AACA,AACA,AACA,AACA,AACA;;;;;uDACA;yBACA;aACA;AACA;AACA;;AACA,AACA,AACA,AACA,AACA;;;;;uDACA;yBACA;aACA;AACA;AACA;;AACA,AACA,AACA,AACA,AACA,AACA;;;;;;;AACA;;8BACA;;;AACA;;+BACA;cACA,iBACA,cACA;gBACA,AACA;;AACA;AACA;;AACA,AACA,AACA,AACA;;;;;YAEA;kCACA;gCACA;AACA,AACA,AACA;AANA;AA7EA;;AAoFA,AACA,AACA,AACA,AACA;;;;;8BACA;4BACA;AACA;;AACA,AACA,AACA,AACA,AACA;;;;;0CACA;SACA;AACA;;AAEA,AACA,AACA,AACA,AACA,AAEA;;;;;;AACA,AACA;AATA;;;;;;;;qEAUA;;;;;gCACA,AACA;;;qBACA;;gEACA;;;;mCACA;6EACA;;0BACA;;;0BACA;;AACA;;mDACA;yCACA;6DACA;4CACA;uDACA;8DACA;6CACA;oEACA;uBACA;mCACA;AACA;;oCACA;8BACA;;;uBACA;;;oCACA;yCACA;0CACA;gDACA;oCACA;qCACA;uDACA,AACA;;;;;;;;;;;;;;;AACA,AACA,AACA;;;sCACA;0BACA;;gCACA;gCACA;uBACA,AACA;;sBACA;2BACA;4BACA;AACA;AACA;;AACA,AACA,AACA,AACA,AACA,AACA;;;;;;;AACA;;wIACA;;0HACA;AACA;;AACA,AACA,AACA,AACA;;;;;AACA;;6BACA;6BACA;;AACA,qBACA;;;yCACA;;+BACA;yCACA;AACA;;iDACA;AACA;AACA;AACA;;AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA;;;;;;;;;AACA;;6BACA;6BACA;;AACA,qBACA;;;yCACA;;+BACA;kCACA;iBACA;qCACA;wDACA;0DACA;gCACA,iBACA,+BACA,gCACA,mCACA,AACA;;;;;uBAEA;uBACA,AACA;AAHA;;AAIA;;iDACA;AACA;AACA;AACA,AACA;;AA7SA","file":"QrcodeReader.vue","sourceRoot":"src/components","sourcesContent":["<template lang=\"html\">\n  <div class=\"qrcode-reader\">\n    <video\n      ref=\"video\"\n      class=\"qrcode-reader__camera\"\n    ></video>\n\n      \n    <div class=\"qrcode-reader__overlay\">\n      <slot></slot>\n    </div>\n      <div>{{decodeResult}}\n    </div>\n  </div>\n</template>\n\n<script>\n    var $ = require('jquery')\nimport jsQR from 'jsqr'\nimport isBoolean from 'lodash/isBoolean'\nconst NO_LOCATION = [] // use specific array instance to guarantee equality ([] !== [] but NO_LOCATION === NO_LOCATION)\nconst LOCATE_INTERVAL = 40 // milliseconds\nconst DECODE_INTERVAL = 400 // milliseconds\nexport default {\n    name: \"qrcode-reader\",\n  props: {\n    paused: {\n      type: Boolean,\n      default: false,\n    },\n    videoConstraints: {\n      type: [Object, Boolean],\n      default: () => ({}), // empty object\n    },\n  },\n  data () {\n    return {\n      // current video stream instance returned by `getUserMedia`\n      stream: null,\n      // absolute resolution of the current video stream\n      streamWidth: null,\n      streamHeight: null,\n      // whether or not first frame of current video stream has loaded yet\n      streamLoaded: true,\n      // most recent decoded QR code content.\n      // Is only null after unpause or before init, otherwise string.\n      decodeResult: null,\n      // array of most recent detected QR code corner coordinates\n      locateResult: NO_LOCATION,\n      // canvas 2D rendering context to capture stream frames with\n      canvasContext: null,\n    }\n  },\n  computed: {\n    /**\n     * Conditions applying for both locating and decoding, joined in a single\n     * computed property.\n     */\n    shouldScan () {\n      return !this.paused && this.streamLoaded\n    },\n    /**\n     * QR codes should only be actively decoded if the parent component has an\n     * event listener registered. Otherwise the rather expensive decoding\n     * operation is continuously executed for nothing.\n     */\n    shouldDecode () {\n      return this.shouldScan && this.$listeners.decode !== undefined\n    },\n    /**\n     * Just like with `this.shouldDecode`, locating is not allowed when the\n     * parent component has no event listener registered.\n     */\n    shouldLocate () {\n      return this.shouldScan && this.$listeners.locate !== undefined\n    },\n    /**\n     * Full constraints object which is passed to `getUserMedia` to request a\n     * camera stream. Properties define if a certain camera is adequate or not.\n     */\n    constraints () {\n      let withDefaults\n      if (isBoolean(this.videoConstraints)) {\n        withDefaults = this.videoConstraints\n      } else {\n        withDefaults = {\n          facingMode: { ideal: 'environment' },\n          width: { min: 360, ideal: 360, max: 720 },\n          height: { min: 240, ideal: 240, max: 480 },\n          ...this.videoConstraints,\n        }\n      }\n      return {\n        audio: false,\n        video: withDefaults,\n      }\n    },\n    /**\n     * Joins stream resolution information in a single array. Some canvas API\n     * methods expect parameters in this form and order. This is a nice little\n     * helper to pass those values with the spread operator.\n     */\n    streamBounds () {\n      return [0, 0, this.streamWidth, this.streamHeight]\n    },\n  },\n  watch: {\n    /**\n     * Propagate new decoding results to parent component. Since holding a\n     * camera for a few seconds over a QR code, produces the same result\n     * multiple times in a row, an event is only emitted when the result\n     * value actually changes. To allow re-scanning after the component is\n     * un-paused, decodeResult is set to null (see #8). Null values are never\n     * emitted though.\n     */\n    decodeResult (newValue) {\n      if (newValue !== null) {\n        this.$emit('decode', newValue)\n      }\n    },\n    /**\n     * Propagates location of QR code when it changes. Just like with decoding\n     * results, this event is only emitted when the detected location changes.\n     *\n     * While a QR code is actually in sight, position changes are detected\n     * nearly each scanned frame anyway. While no QR code is detected though,\n     * this makes sure that empty results are only emitted once.\n     */\n    locateResult (newValue) {\n      this.$emit('locate', newValue)\n    },\n    /**\n     * Automatically freezes the video stream when conditions for the scanning\n     * process are not fullfilled anymore.\n     */\n    shouldScan (shouldScan) {\n      if (shouldScan) {\n        this.$refs.video.play()\n      } else {\n        this.$refs.video.pause()\n      }\n    },\n    /**\n     * Starts continuous decoding process as soon as conditions for that are\n     * fullfilled. The process stops itself automatically when the conditions\n     * are not fullfilled anymore.\n     */\n    shouldDecode (shouldDecode) {\n      if (shouldDecode) {\n        this.keepDecoding()\n      }\n    },\n    /**\n     * Starts continuous locating process as soon as conditions for that are\n     * fullfilled. The process stops itself automatically when the conditions\n     * are not fullfilled anymore.\n     */\n    shouldLocate (shouldLocate) {\n      if (shouldLocate) {\n        this.keepLocating()\n      }\n    },\n    /**\n     * Resets decodeResult when component is un-paused. This way one QR code\n     * can be decoded twice in a row (see #8). Waits though until video is\n     * actually not frozen anymore. Otherwise the last frame from before\n     * pausing would be rescanned.\n     */\n    paused (newValue) {\n      if (newValue === false) {\n        const resetDecodeResult = () => { this.decodeResult = null }\n        const video = this.$refs.video\n        video.addEventListener(\n          'timeupdate',\n          resetDecodeResult,\n          { once: true }\n        )\n      }\n    },\n    /**\n     * When constraints for the used camera change, a new stream has to be\n     * requested. This bootstraps the hole init process again.\n     */\n    constraints: {\n      deep: true,\n      handler () {\n        this.$emit('init', this.startCamera())\n      },\n    },\n  },\n  /**\n   * Instanly requests a stream from the users camera as soon as the component\n   * is mounted. This can't be done in earlier livecycle hooks because it\n   * requires the video and canvas element to be rendered already.\n   */\n  mounted () {\n    this.$emit('init', this.startCamera())\n  },\n  /**\n   * If the camera is not released before the component is destroyed, browsers\n   * will indicate that it's still in use and it might be blocked for other\n   * applications.\n   */\n  beforeDestroy () {\n    this.stopCamera()\n  },\n  methods: {\n    /**\n     * Requests a camera stream using the Stream API and based on\n     * `this.constraints`. Then connects the stream to the video element and\n     * waits for it to load. The promise returned here is the payload for the\n     * `init` event. Any error here leads to this promises rejection.\n     */\n      \n    async startCamera () {\n      // check if browser is support first\n      if (!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)) {\n        throw new Error('WebRTC API not supported in this browser')\n      }\n      this.stopCamera()\n      this.stream = await navigator.mediaDevices.getUserMedia(this.constraints)\n      const video = this.$refs.video\n      const streamLoadedPromise = new Promise((resolve, reject) => {\n        video.addEventListener('loadeddata', resolve, { once: true })\n        video.addEventListener('error', reject, { once: true })\n      })\n      if (video.srcObject !== undefined) {\n        video.srcObject = this.stream\n      } else if (video.mozSrcObject !== undefined) {\n        video.mozSrcObject = this.stream\n      } else if (window.URL.createObjectURL) {\n        video.src = window.URL.createObjectURL(this.stream)\n      } else if (window.webkitURL) {\n        video.src = window.webkitURL.createObjectURL(this.stream)\n      } else {\n        video.src = this.stream\n      }\n      video.playsInline = true\n      video.play() // firefox does not emit `loadeddata` if video not playing\n      await streamLoadedPromise\n      this.streamLoaded = true\n      this.streamWidth = video.videoWidth\n      this.streamHeight = video.videoHeight\n      const canvas = document.createElement('canvas')\n      canvas.width = this.streamWidth\n      canvas.height = this.streamHeight\n      this.canvasContext = canvas.getContext('2d')\n    },\n    /**\n     * Releases the current camera stream and resets related instance properties.\n     */\n    stopCamera () {\n      this.streamLoaded = false\n      if (this.stream !== null) {\n        this.stream.getTracks().forEach(\n          track => track.stop()\n        )\n        this.stream = null\n        this.streamWidth = null\n        this.streamHeight = null\n      }\n    },\n    /**\n     * Captures a frame from video stream and draws it to canvas. Then reads\n     * image data from canvas and returns it for further analysis. This extra\n     * step is necessary because it's not possible to read image data from a\n     * video element directly.\n     */\n    captureFrame () {\n      this.canvasContext.drawImage(this.$refs.video, ...this.streamBounds)\n      return this.canvasContext.getImageData(...this.streamBounds)\n    },\n    /**\n     * Continuously extracts frames from camera stream and tries to decode\n     * potentially pictured QR codes.\n     */\n    keepDecoding () {\n      if (this.shouldDecode) {\n        const imageData = this.captureFrame()\n        window.requestAnimationFrame(() => {\n          const { data, width, height } = imageData\n          const result = jsQR(data, width, height)\n          if (result !== null) {\n            this.decodeResult = result.data\n          }\n          window.setTimeout(this.keepDecoding, DECODE_INTERVAL)\n        })\n      }\n    },\n    /**\n     * Continuously extracts frames from camera stream and tries to locate\n     * potentially pictured QR codes.\n     *\n     * The coordinates are based on the original camera resolution but the\n     * video element is responsive and scales with space available. Therefore\n     * the coordinates are re-calculated to be relative to the video element.\n     */\n    keepLocating () {\n      if (this.shouldLocate) {\n        const imageData = this.captureFrame()\n        window.requestAnimationFrame(() => {\n          const { data, width, height } = imageData\n          const result = jsQR(data, width, height)\n          if (result === null) {\n            this.locateResult = NO_LOCATION\n          } else {\n            const video = this.$refs.video\n            const widthRatio = video.offsetWidth / this.streamWidth\n            const heightRatio = video.offsetHeight / this.streamHeight\n            const locationArray = [\n              result.location.topLeftCorner,\n              result.location.topRightCorner,\n              result.location.bottomRightCorner,\n              result.location.bottomLeftCorner,\n            ]\n            this.locateResult = locationArray.map(({ x, y }) => ({\n              x: x * widthRatio,\n              y: y * heightRatio,\n            }))\n          }\n          window.setTimeout(this.keepLocating, LOCATE_INTERVAL)\n        })\n      }\n    },\n  },\n}\n</script>\n\n<style lang=\"css\">\n.qrcode-reader {\n  position: relative;\n      top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  display: block;\n}\n.qrcode-reader__camera {\n  display: block;\n  object-fit: contain;\n  max-width: 100%;\n  max-height: 100%;\n}\n.qrcode-reader__overlay {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n</style>"]}]}